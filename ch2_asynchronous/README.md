# 2章 非同期プログラミング

## 目次
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [2章 非同期プログラミング](#2章-非同期プログラミング)
  - [目次](#目次)
  - [2.1 イベントループと非同期プログラミング](#21-イベントループと非同期プログラミング)
    - [2.1.1 マルチスレッドによる並行処理とその問題点](#211-マルチスレッドによる並行処理とその問題点)
      - [2.1.1.1 ブロッキングI/Oとスレッドの切り替えによる並行処理](#2111-ブロッキングioとスレッドの切り替えによる並行処理)
      - [2.1.1.2 マルチスレッドの問題点](#2112-マルチスレッドの問題点)
    - [2.1.2 イベントループによる並行処理と非同期プログラミング](#212-イベントループによる並行処理と非同期プログラミング)
      - [2.1.2.1 ノンブロッキングI/Oを利用した並行処理](#2121-ノンブロッキングioを利用した並行処理)
      - [2.1.2.2 マルチスレッドの問題点の解消](#2122-マルチスレッドの問題点の解消)
      - [2.1.2.3 イベントループで注意する点](#2123-イベントループで注意する点)
  - [2.2 コールバック](#22-コールバック)
    - [2.2.1 コールバックを利用した非同期APIを実行する](#221-コールバックを利用した非同期apiを実行する)

<!-- /code_chunk_output -->

イベントループで並行処理を実現するには非同期プログラミングが不可欠  
この章ではマルチスレッドとイベントループの違いを深く知り、非同期プログラミングの必要性を学ぶ 

## 2.1 イベントループと非同期プログラミング
### 2.1.1 マルチスレッドによる並行処理とその問題点

#### 2.1.1.1 ブロッキングI/Oとスレッドの切り替えによる並行処理

マルチスレッドで並行処理を実現する言語では、コンビニでのレジの処理はこのようになる
```
    const  金額 = バーコードリーダー.読む(弁当) //1
    const 温まった弁当 = 電子レンジ.チン(弁当)  //2
    レジ.会計する(金額)
    商品を渡す(温まった弁当)
```
1,2の構文的な違いはなく、どちらもメソッドを実行してその戻り値を変数に代入している   
しかし実際のオペレーションでは、それぞれの行でおこることの性質が異なる    
* 「弁当」に対する「バーコードリーダー」の処理は短い操作ですぐに金額を得ることができる  
* 電子レンジで弁当を温める処理は時間のかかる処理    
そのため、長い処理が終わるまで処理の実行が止まってしまう  

時間のかかる処理＝＝＞ブロッキング  
I/Oである場合は**ブロッキングI/O**と呼ばれる  
並行処理を実現するには、待ち時間に別の作業を実行する必要があるが、ブロッキングな処理では、そのような処理は表現されない。  

マルチスレッド：実行状況に応じて、スレッドを切り替えることで並行処理を実現。

#### 2.1.1.2 マルチスレッドの問題点
C10K：スレッドごとにスタックと呼ばれるメモリ領域を持っているため、ハードウェアのメモリの容量の制約を受け、最大接続数が制限される。

マルチスレッドでは、プログラマーはスレッドセーフにコードを保たないといけない。  
  スレッドセーフ：複数のスレッドが並列に実行しても問題が起きないこと。更新操作の競合を防ぐ。
&rarr; スレッド間で、値を共有しないようにプログラムを組む
or 共有する値をロックを取得し、処理が終了するまで他のスレッドからの更新を防ぐ、しかしロックはパフォーマンスに悪影響を与える

### 2.1.2 イベントループによる並行処理と非同期プログラミング

イベントループ：シングルスレッドで動作
&rarr;マルチスレッドの問題がない

#### 2.1.2.1 ノンブロッキングI/Oを利用した並行処理

マルチスレッド&rarr;スレッドを自動で切り替え
イベントループ&rarr;完了後のタスクを指定して実行

疑似コード
```
const 金額 = バーコードリーダー.読む(弁当)
電子レンジ.チン(
  弁当,
  // 第二引数に完了後のタスク指定
  温まった弁当 => 商品を渡す(温まった弁当)
)
レジ.会計する(金額)
```
プログラムは、先にレジの会計をしてから、商品を渡す

ノンブロッキングI/O  

#### 2.1.2.2 マルチスレッドの問題点の解消
C10K問題をイベントループによる並行処理で解決することができる。  
メモリの負荷もあまり課から何

#### 2.1.2.3 イベントループで注意する点

* 非同期プログラミングの複雑さ
  * **マルチスレッド**：
    * **メリット**：簡単に記述できる
    * **デメリット**：コードから制御する難易度が高く、複雑な実装になる
  * **イベントループ**並列処理を柔軟に制御でき、スレッドセーフなどの配慮が不要
    * **デメリット**：制御フローが複雑になりやすい

* CPU負荷の高い処理の扱い
  * イベントループの並行処理は**I/Oを多用するアプリケーションの開発に適している**
  * CPUを使った負荷の高いアプリケーションでは、注意が必要

## 2.2 コールバック

JavaScriptの非同期プログラムで最も基本的な実装パターン  
非同期処理を行う関数の引数として、コールバックを私、処理が終わると実行される。  

### 2.2.1 コールバックを利用した非同期APIを実行する

[time_out.js](time_out.js)
```
setTimeout(
    ()=>console.log('1秒経過しました'), //コールバック
    1000 //1000ミリ秒
)
console.log('setTimeoutを実行しました')

```

先に「setTimeoutを実行しました」が実行される。

コールバックを利用しているからといって、必ず非同期になるわけではない。
